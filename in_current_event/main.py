import functions_framework
from ics import Calendar
import arrow
import requests
import json
from flask import jsonify


# URL of the "Services" calendar feed and our webhook receiver on Make
SERVICES_URL = "https://stcatherinechurch.onechurchsoftware.com/api/calendars/feed/7iWxebAmvU5PJQgQXh663Cut1ALT9Sz+j+xA==G8Mcb69uvXI0GK8adgGCPXVWnNPI/ni32/fj4/A30Pw==t7aqLeA2Q7ky2C"
WEBHOOK_URL = "https://hook.us1.make.com/dfway9mqu3kb1kdnj6bsveudpaenlkod"

# Convert output times to local
timezone = "US/Mountain"

# How far out to retrieve events (days)
# In this case we just want to look at the current or first upcoming event,
# but we need to look out a few days to make sure something gets returned
event_window = 10

# One Church domain (this is used to strip out the event uid)
# INCLUDE THE '@' symbol!
ONECHURCH_DOMAIN = "@stcatherinechurch.onechurchsoftware.com"

class StreamableEvent():
    def __init__(self, id, title, start, end):
        self.id = id        # ID of the event. We use the one generated by One Church to keep things consistent
        self.title = title
        self.start_time = start
        self.end_time = end

    def __repr__(self):
        return 'StreamableEvent(\n\tid:%s\n\tname:%s\n\t(%s to %s)\n)' % (
            self.id, self.title,
            self.start_time, self.end_time)


def get_stream_timeline(url, my_tz, window):

    try:
        calendar = Calendar(requests.get(SERVICES_URL).text)
    except Exception as e:
        print(e)

    # initialize an empty list for the events
    event_list = []

    # populate the event list with just the components that we need
    # Event ID, Event Name, and start/stop times
    # Use the ics 'timeline' iterator to return the events in chronological order
    for event in calendar.timeline:

        if arrow.utcnow() < event.end < arrow.utcnow().shift(days=event_window):
            
            event_list.append(StreamableEvent(event.uid.removesuffix(ONECHURCH_DOMAIN),
                                event.name,
                                event.begin.to(timezone),
                                event.end.to(timezone)
                                )
            )
    # logging.info("Processed %d events", len(event_list))
    return(event_list)

def shorten_title(title):
    return title[:title.find('Orthros')-1] if title.find('Orthros') > 0 else title

def event_in_progress(event):

    event_state = dict()

    print("\nEvent '%s' begins at %s" % (shorten_title(event.title),event.start_time.ctime()))
    current_time = arrow.utcnow().to(timezone)
    event_state['current_time'] = current_time.format()
    event_state['event_start_time'] = event.start_time.ctime()
    event_state['short_title'] = shorten_title(event.title)

    if event.start_time < current_time < event.end_time:
        event_state['in_progress'] = "True"
    else:
        event_state['in_progress'] = "False"

    return event_state

def send_to_webhook(url,payload_data):

    response = requests.post(
        url,
        data=json.dumps(payload_data),
        headers={'Content-Type': 'application/json'}
        )
    
    if response.status_code != 200:
        raise ValueError(
            'Request to webhook returned an error %s, the response is:\n%s'
            % (response.status_code, response.text)
        )


@functions_framework.http
def in_current_event(request):

    today_events = get_stream_timeline(SERVICES_URL, timezone, event_window)
    # Return the first event in the list, which should be the active or first upcoming one
    if len(today_events) > 0: # Make sure we got at least one event
        first_event = event_in_progress(today_events[0])
    else:
        return "No events found. Try a longer window."

    try:
        send_to_webhook(WEBHOOK_URL,first_event)
    except Exception as e:
        print(e)
                
    return jsonify.dump(first_event)
