#!/usr/bin/env python

from ics import Calendar
import arrow
import requests
from pprint import pprint, pformat
import logging, sys

logging.basicConfig(stream=sys.stderr, level=logging.INFO)
logging.debug('A debug message!')
# logging.info('We processed %d records', len(processed_records))

# URL of the "Services" calendar feed
SERVICES_URL = "https://stcatherinechurch.onechurchsoftware.com/api/calendars/feed/7iWxebAmvU5PJQgQXh663Cut1ALT9Sz+j+xA==G8Mcb69uvXI0GK8adgGCPXVWnNPI/ni32/fj4/A30Pw==t7aqLeA2Q7ky2C"
WEBHOOK_URL = "https://hook.us1.make.com/dfway9mqu3kb1kdnj6bsveudpaenlkod"

# Convert output times to local
timezone = "US/Mountain"

# How far out to retrieve events (days)
# In this case we just want to look at the current or first upcoming event
event_window = 10

# One Church domain (this is used to strip out the event uid)
# INCLUDE THE '@' symbol!
oc_domain = "@stcatherinechurch.onechurchsoftware.com"

class StreamableEvent():
    def __init__(self, id, title, start, end):
        self.id = id        # ID of the event. We use the one generated by One Church to keep things consistent
        self.title = title
        self.start_time = start
        self.end_time = end

    def __repr__(self):
        return 'StreamableEvent(\n\tid:%s\n\tname:%s\n\t(%s to %s)\n)' % (
            self.id, self.title,
            self.start_time, self.end_time)


def get_stream_timeline(url, my_tz, window):

    try:
        calendar = Calendar(requests.get(SERVICES_URL).text)
    except Exception as e:
        print(e)

    # initialize an empty list for the events
    event_list = []

    # populate the event list with just the components that we need
    # Event ID, Event Name, and start/stop times
    # Use the ics 'timeline' iterator to return the events in chronological order
    for event in calendar.timeline:

        if arrow.utcnow() < event.end < arrow.utcnow().shift(days=event_window):
            # What's in this thing?
            logging.debug(pformat(event.__dict__))

            event_list.append(StreamableEvent(event.uid.removesuffix(oc_domain),
                                event.name,
                                event.begin.to(timezone),
                                event.end.to(timezone)
                                )
            )
    logging.info("Processed %d events", len(event_list))
    return(event_list)

def shorten_title(title):
    return title[:title.find('Orthros')-1]

def event_in_progress(event):
    # What's in this thing?
    logging.info(pformat(event.__dict__))

    print("\nEvent '%s' begins at %s" % (shorten_title(event.title),event.start_time.ctime()))

    current_time = arrow.utcnow().to(timezone)
    if event.start_time < current_time < event.end_time:
        print("It is now %s: Event IS currently in progress" % current_time.ctime())
        return True
    else:
        print("It is now %s: Event IS NOT in progress" % current_time.ctime())
        return False

def send_to_webhook(webhook_url,payload_data):

    response = requests.post(
        WEBHOOK_URL,
        data=json.dumps(payload_data),
        headers={'Content-Type': 'application/json'}
        )
    
    if response.status_code != 200:
        raise ValueError(
            'Request to webhook returned an error %s, the response is:\n%s'
            % (response.status_code, response.text)
        )

if __name__ == '__main__':

    today_events = get_stream_timeline(SERVICES_URL, timezone, event_window)

    # print(today_events)
    for event in today_events:
        event_in_progress(event)
        if event_in_progress(event)['inprogress'] is True:
            send_to_webhook(WEBHOOK_URL,event)
    
